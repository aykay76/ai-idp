# YAML Schema Design: Group/Version/Kind API Specification

## Overview

This document defines the YAML schema design for the AI-powered Internal Developer Platform, using Kubernetes-style group/version/kind API specifications that map directly to platform services and resource providers.

## 1. API Group Architecture

### 1.1 API Group Mapping to Platform Components

```yaml
api_groups:
  # Core Platform APIs (handled by core platform services)
  platform.company.com:
    services:
      - application-service      # Applications and metadata
      - team-service            # Team management and ownership
      - policy-service          # Governance and compliance
    versions: [v1alpha1, v1beta1, v1]
    
  # Infrastructure Resource APIs (handled by resource providers)  
  infrastructure.company.com:
    services:
      - database-provider       # Database resources
      - cache-provider         # Redis, Memcached
      - messaging-provider     # Kafka, RabbitMQ
    versions: [v1alpha1, v1beta1, v1]
    
  # Source Control APIs (handled by SCM providers)
  scm.company.com:
    services:
      - github-provider        # GitHub integration
      - gitlab-provider        # GitLab integration  
      - bitbucket-provider     # Bitbucket integration
    versions: [v1alpha1, v1beta1, v1]
    
  # Workload APIs (handled by orchestration providers)
  workloads.company.com:
    services:
      - kubernetes-provider    # K8s workloads
      - container-provider    # Container management
      - serverless-provider   # Lambda, Functions
    versions: [v1alpha1, v1beta1, v1]
```

### 1.2 Version Strategy

```yaml
version_lifecycle:
  v1alpha1:
    stability: "unstable"
    breaking_changes: "allowed"  
    purpose: "early development, rapid iteration"
    
  v1beta1:
    stability: "beta"
    breaking_changes: "minimal, with migration path"
    purpose: "feature complete, pre-production testing"
    
  v1:
    stability: "stable"  
    breaking_changes: "not allowed"
    purpose: "production ready, backward compatibility guaranteed"
    
deprecation_policy:
  minimum_support: "3 versions"
  deprecation_warning: "2 versions before removal"
  migration_tools: "automatic conversion provided"
```

## 2. Core Schema Examples

### 2.1 Application Schema

**API Mapping**: `platform.company.com/v1` → `application-service`

```yaml
apiVersion: platform.company.com/v1
kind: Application
metadata:
  name: ecommerce-platform
  namespace: retail-team  # Maps to tenant isolation
  labels:
    domain: "retail"
    criticality: "high"
    cost-center: "retail-eng"
  annotations:
    platform.company.com/created-by: "john.doe@company.com"
    platform.company.com/ai-generated: "true"
    
spec:
  # Application metadata and configuration
  displayName: "E-Commerce Platform"
  description: "Customer-facing e-commerce application with microservices architecture"
  
  # Ownership and team information
  team: retail-backend-team
  owner: platform-team@company.com
  
  # Application lifecycle and environment settings
  lifecycle: production
  environment: 
    name: production
    region: us-east-1
    
  # Resource quotas and limits (tenant-level controls)
  resourceQuota:
    cpu: "20000m"      # 20 cores max
    memory: "40Gi"     # 40GB RAM max
    storage: "500Gi"   # 500GB storage max
    monthlyBudget: 5000 # $5000/month
    
  # Compliance and governance settings
  compliance:
    dataResidency: us-east-1
    encryptionRequired: true
    auditLevel: comprehensive
    
  # Application dependencies (references to other applications)
  dependencies:
    - name: user-authentication-service
      version: ">=2.0.0"
      required: true
    - name: payment-gateway
      version: ">=1.5.0" 
      required: true
      
  # Monitoring and observability configuration
  observability:
    metrics:
      enabled: true
      retention: 30d
    logging:
      level: info
      retention: 7d
    tracing:
      enabled: true
      samplingRate: 0.1
      
status:
  # Status fields (managed by platform, read-only for users)
  phase: "Running"  # Pending, Running, Failed, Terminating
  conditions:
    - type: "Ready"
      status: "True"
      lastTransitionTime: "2024-01-15T10:30:00Z"
  resources:
    current:
      cpu: "12000m"
      memory: "25Gi"
      monthlySpend: 3200
  lastReconciled: "2024-01-15T10:35:00Z"
```

**JSON Schema Validation**:
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Application",
  "type": "object",
  "required": ["apiVersion", "kind", "metadata", "spec"],
  "properties": {
    "apiVersion": {
      "type": "string",
      "enum": ["platform.company.com/v1alpha1", "platform.company.com/v1beta1", "platform.company.com/v1"]
    },
    "kind": {
      "type": "string",
      "enum": ["Application"]
    },
    "metadata": {
      "$ref": "#/definitions/ObjectMeta"
    },
    "spec": {
      "type": "object",
      "required": ["team", "owner"],
      "properties": {
        "displayName": {"type": "string", "maxLength": 100},
        "description": {"type": "string", "maxLength": 500},
        "team": {"type": "string", "pattern": "^[a-z0-9-]+$"},
        "owner": {"type": "string", "format": "email"},
        "lifecycle": {
          "type": "string", 
          "enum": ["development", "staging", "production", "deprecated"]
        },
        "resourceQuota": {
          "type": "object",
          "properties": {
            "cpu": {"type": "string", "pattern": "^[0-9]+m?$"},
            "memory": {"type": "string", "pattern": "^[0-9]+(Ki|Mi|Gi|Ti)$"},
            "monthlyBudget": {"type": "number", "minimum": 0}
          }
        }
      }
    }
  }
}
```

### 2.2 Service Schema  

**API Mapping**: `workloads.company.com/v1` → `kubernetes-provider`

```yaml
apiVersion: workloads.company.com/v1
kind: Service
metadata:
  name: user-api
  namespace: retail-team
  labels:
    app.kubernetes.io/name: user-api
    app.kubernetes.io/part-of: ecommerce-platform
    app.kubernetes.io/component: backend
  ownerReferences:
    - apiVersion: platform.company.com/v1
      kind: Application
      name: ecommerce-platform
      uid: 12345678-1234-1234-1234-123456789012
      
spec:
  # Container specification
  image: 
    repository: ecommerce/user-api
    tag: "v2.1.0"
    pullPolicy: Always
    
  # Service configuration  
  port: 8080
  protocol: HTTP
  healthCheck:
    path: /health
    initialDelaySeconds: 30
    timeoutSeconds: 5
    
  # Resource requirements
  resources:
    requests:
      cpu: "500m"
      memory: "512Mi"
    limits:
      cpu: "2000m" 
      memory: "2Gi"
      
  # Scaling configuration
  scaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 10
    targetCPUUtilization: 70
    targetMemoryUtilization: 80
    
  # Environment configuration
  env:
    - name: NODE_ENV
      value: "production"
    - name: DATABASE_URL
      valueFrom:
        resourceRef:
          apiVersion: infrastructure.company.com/v1
          kind: Database  
          name: user-db
          field: connectionString
    - name: REDIS_URL
      valueFrom:
        resourceRef:
          apiVersion: infrastructure.company.com/v1
          kind: Cache
          name: user-cache
          field: url
    - name: API_KEY
      valueFrom:
        secretRef:
          name: user-api-secrets
          key: api-key
          
  # Network configuration
  networking:
    ingress:
      enabled: true
      host: api.ecommerce.company.com
      path: /users
      tls: true
    service:
      type: ClusterIP
      ports:
        - name: http
          port: 8080
          targetPort: 8080
          
  # Security context
  security:
    runAsNonRoot: true
    runAsUser: 1000
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: true
    
status:
  replicas: 3
  readyReplicas: 3
  conditions:
    - type: "Available"
      status: "True"
  lastDeployment: "2024-01-15T09:45:00Z"
```

### 2.3 Team Schema

**API Mapping**: `platform.company.com/v1` → `team-service`

```yaml
apiVersion: platform.company.com/v1
kind: Team
metadata:
  name: retail-backend-team
  labels:
    department: "engineering"
    domain: "retail"
    cost-center: "eng-retail"
    
spec:
  # Team identification and metadata
  displayName: "Retail Backend Team"
  description: "Responsible for e-commerce backend services and APIs"
  
  # Team structure and membership
  lead: john.doe@company.com
  members:
    - email: john.doe@company.com
      role: tech-lead
      permissions: ["admin"]
    - email: jane.smith@company.com  
      role: senior-developer
      permissions: ["developer", "reviewer"]
    - email: bob.wilson@company.com
      role: developer
      permissions: ["developer"]
    - email: alice.brown@company.com
      role: devops-engineer  
      permissions: ["developer", "deployer"]
      
  # Team contacts and communication
  contacts:
    slack: "#retail-backend"
    email: retail-backend@company.com
    oncall: retail-backend-oncall@company.com
    
  # Organizational structure
  department: engineering
  organization: retail-division
  manager: sarah.jones@company.com
  
  # Resource ownership and responsibilities
  ownership:
    applications:
      - ecommerce-platform
      - user-management-service
      - inventory-service
    domains:
      - "retail.company.com"
      - "api.ecommerce.company.com"
    repositories:
      - ecommerce-backend
      - user-service
      - inventory-service
      
  # Team policies and governance
  policies:
    codeReview:
      required: true  
      minimumReviewers: 2
      requireCodeOwnerReview: true
    deployment:
      productionApproval: required
      approvers: ["john.doe@company.com", "jane.smith@company.com"]
    security:
      secretAccess: restricted
      privilegedAccess: approval-required
      
  # Budget and cost management
  budget:
    monthly: 15000  # $15K/month
    quarterly: 45000
    approver: sarah.jones@company.com
    alerts:
      - threshold: 80
        recipients: ["john.doe@company.com"]
      - threshold: 95
        recipients: ["john.doe@company.com", "sarah.jones@company.com"]
        
status:
  memberCount: 4
  activeApplications: 3
  monthlySpend: 12500
  lastUpdated: "2024-01-15T08:00:00Z"
```

### 2.4 Repository Schema

**API Mapping**: `scm.company.com/v1` → `github-provider`

```yaml
apiVersion: scm.company.com/v1
kind: Repository
metadata:
  name: user-service-repo
  labels:
    scm.company.com/provider: "github"
    app.kubernetes.io/part-of: ecommerce-platform
  ownerReferences:
    - apiVersion: platform.company.com/v1
      kind: Team
      name: retail-backend-team
      
spec:
  # Repository identification
  name: user-management-service
  description: "Microservice for user authentication and profile management"
  
  # SCM provider configuration
  provider:
    type: github
    organization: company-engineering
    
  # Repository settings
  visibility: private
  defaultBranch: main
  
  # Access control and permissions
  access:
    teams:
      - name: retail-backend-team
        permission: admin
      - name: platform-team  
        permission: maintain
    users:
      - username: john.doe
        permission: admin
        
  # Branch protection rules
  branchProtection:
    main:
      enforceAdmins: false
      requiredStatusChecks:
        strict: true
        contexts:
          - "ci/build"
          - "ci/test"
          - "security/scan"
      requiredPullRequestReviews:
        required: true
        reviewerCount: 2
        dismissStaleReviews: true
        requireCodeOwnerReviews: true
        requireLastPushApproval: true
      restrictions:
        users: []
        teams: ["retail-backend-team"]
        apps: ["github-actions"]
        
  # CI/CD integration
  cicd:
    provider: github-actions
    workflows:
      - name: "Build and Test"
        trigger: [push, pull_request]
        file: ".github/workflows/ci.yml"
      - name: "Deploy to Staging"
        trigger: [push]
        branches: [main]
        file: ".github/workflows/deploy-staging.yml"
      - name: "Deploy to Production"
        trigger: [workflow_dispatch]
        file: ".github/workflows/deploy-production.yml"
        requiresApproval: true
        
  # Repository hooks and integrations
  webhooks:
    - url: "https://platform.company.com/webhooks/github"
      events: ["push", "pull_request", "issues"]
      active: true
      
  # Code quality and security
  quality:
    codeScanning:
      enabled: true
      tool: "codeql"
      schedule: "weekly"
    dependencyReview:
      enabled: true
      autoMergeMinorUpdates: true
    secretScanning:
      enabled: true
      alertRecipients: ["retail-backend@company.com"]
      
  # Repository topics and metadata
  topics:
    - "microservice"
    - "nodejs"
    - "authentication"
    - "retail"
    
  # License and documentation
  license: MIT
  documentation:
    readme: "README.md"
    contributing: "CONTRIBUTING.md"
    codeOfConduct: "CODE_OF_CONDUCT.md"
    
status:
  url: "https://github.com/company-engineering/user-management-service"
  cloneUrl: "git@github.com:company-engineering/user-management-service.git"
  size: 1250  # KB
  language: "JavaScript"
  lastCommit:
    sha: "abc123def456"
    author: "jane.smith@company.com"
    message: "Fix user validation logic"
    timestamp: "2024-01-15T14:30:00Z"
  openIssues: 3
  openPullRequests: 2
```

## 3. Schema Validation and Generation

### 3.1 Validation Pipeline Architecture

```go
// Schema validation service mapping
type SchemaValidator struct {
    schemaRegistry map[string]SchemaDefinition
    validators     map[string]Validator
}

type SchemaDefinition struct {
    APIVersion    string
    Kind         string
    JSONSchema   string
    APIGroup     string
    ServiceName  string  // Maps to platform service
}

var SchemaRegistry = map[string]SchemaDefinition{
    "platform.company.com/v1/Application": {
        APIVersion:  "platform.company.com/v1",
        Kind:        "Application",
        JSONSchema:  ApplicationV1Schema,
        APIGroup:    "platform.company.com",
        ServiceName: "application-service",
    },
    "workloads.company.com/v1/Service": {
        APIVersion:  "workloads.company.com/v1", 
        Kind:        "Service",
        JSONSchema:  ServiceV1Schema,
        APIGroup:    "workloads.company.com",
        ServiceName: "kubernetes-provider",
    },
    "platform.company.com/v1/Team": {
        APIVersion:  "platform.company.com/v1",
        Kind:        "Team", 
        JSONSchema:  TeamV1Schema,
        APIGroup:    "platform.company.com",
        ServiceName: "team-service",
    },
    "scm.company.com/v1/Repository": {
        APIVersion:  "scm.company.com/v1",
        Kind:        "Repository",
        JSONSchema:  RepositoryV1Schema, 
        APIGroup:    "scm.company.com",
        ServiceName: "github-provider",
    },
}

func (sv *SchemaValidator) ValidateResource(resource *UnstructuredResource) error {
    key := fmt.Sprintf("%s/%s", resource.APIVersion, resource.Kind)
    schemaDef, exists := sv.schemaRegistry[key]
    if !exists {
        return fmt.Errorf("unknown resource type: %s", key)
    }
    
    validator := sv.validators[schemaDef.ServiceName]
    if validator == nil {
        return fmt.Errorf("no validator for service: %s", schemaDef.ServiceName)
    }
    
    return validator.Validate(resource, schemaDef.JSONSchema)
}
```

### 3.2 API Gateway Routing

```yaml
# API Gateway routing configuration
api_routes:
  # Core Platform APIs
  /api/v1/applications:
    service: application-service
    schema_group: platform.company.com
    
  /api/v1/teams:
    service: team-service  
    schema_group: platform.company.com
    
  # Workload APIs
  /api/v1/services:
    service: kubernetes-provider
    schema_group: workloads.company.com
    
  # SCM APIs  
  /api/v1/repositories:
    service: github-provider
    schema_group: scm.company.com
    
  # Infrastructure APIs
  /api/v1/databases:
    service: database-provider
    schema_group: infrastructure.company.com
```

## 4. Extension and Customization

### 4.1 Custom Resource Definitions

```yaml
# Example: Custom resource for ML workloads
apiVersion: ml.company.com/v1alpha1
kind: MLModel
metadata:
  name: recommendation-engine
spec:
  framework: tensorflow
  version: "2.8"
  trainingData:
    source: s3://ml-data/recommendations/
    format: parquet
  inference:
    replicas: 3
    resources:
      gpu: 1
      memory: "4Gi"
```

### 4.2 Vendor-Specific Extensions

```yaml
# Azure-specific database resource
apiVersion: infrastructure.azure.company.com/v1
kind: AzureSQLDatabase  
metadata:
  name: user-db-azure
spec:
  serverName: company-sql-server
  edition: Standard
  serviceObjective: S2
  elasticPool: company-pool
  # Azure-specific features
  azureSpecific:
    threatDetection: true
    advancedDataSecurity: true
    geoReplication:
      enabled: true
      region: westus2
```

## 5. AI Integration Patterns

### 5.1 AI-Generated Configuration Templates

```yaml
# AI prompt: "Create a Node.js microservice with PostgreSQL and Redis"
# AI generates:
apiVersion: platform.company.com/v1
kind: Application
metadata:
  name: "${AI:application_name}"
  annotations:
    platform.company.com/ai-generated: "true"
    platform.company.com/ai-prompt: "Node.js microservice with PostgreSQL and Redis"
spec:
  team: "${AI:team_name}"
  owner: "${AI:user_email}"
---
apiVersion: workloads.company.com/v1  
kind: Service
metadata:
  name: "${AI:service_name}"
spec:
  image:
    repository: "${AI:image_repo}"
    tag: "latest"
  env:
    - name: DATABASE_URL
      valueFrom:
        resourceRef:
          kind: Database
          name: "${AI:db_name}"
---
# Additional resources auto-generated based on prompt...
```

### 5.2 Schema-Aware AI Validation

```go
type AIConfigurationGenerator struct {
    schemaRegistry *SchemaValidator
    llmClient      LLMClient
}

func (ai *AIConfigurationGenerator) GenerateFromPrompt(prompt string) ([]UnstructuredResource, error) {
    // Generate configuration using LLM
    generatedYAML, err := ai.llmClient.GenerateConfiguration(prompt, ai.getSchemaContext())
    if err != nil {
        return nil, err
    }
    
    // Parse and validate against schemas
    resources, err := ai.parseResources(generatedYAML)
    if err != nil {
        return nil, err
    }
    
    // Validate each resource against its schema
    for _, resource := range resources {
        if err := ai.schemaRegistry.ValidateResource(&resource); err != nil {
            // Attempt to fix common issues
            fixed, fixErr := ai.llmClient.FixValidationError(resource, err)
            if fixErr != nil {
                return nil, fmt.Errorf("validation failed and couldn't auto-fix: %w", err)
            }
            resource = fixed
        }
    }
    
    return resources, nil
}
```

## 6. Development Tools Integration

### 6.1 VS Code Extension Schema

```json
{
  "contributes": {
    "languages": [
      {
        "id": "platform-yaml",
        "extensions": [".platform.yaml", ".platform.yml"]
      }
    ],
    "jsonValidation": [
      {
        "fileMatch": "*.platform.yaml",
        "url": "./schemas/platform-schemas.json"
      }
    ],
    "snippets": [
      {
        "language": "platform-yaml",
        "path": "./snippets/platform.json"
      }
    ]
  }
}
```

### 6.2 CLI Tool Schema Integration

```bash
# Platform CLI with schema validation
platform apply -f application.yaml --validate
platform generate application --name ecommerce --team retail
platform schema validate --resource Application --version v1
platform schema convert --from kubernetes --to platform-yaml deployment.yaml
```

This schema design creates a **clean separation of concerns** where each API group maps to specific platform services, while providing a **consistent, familiar interface** for developers. The AI can easily understand and generate these configurations, making your platform truly AI-native!

<function_calls>
<invoke name="todo_write">
<parameter name="merge">true
