# Pluggable Resource Managers Architecture

## 1. Overview

The resource manager layer provides a pluggable architecture for managing different types of infrastructure resources (databases, caches, git repositories, CI/CD pipelines, etc.). Each resource type has a dedicated manager that implements a common interface, enabling consistent management patterns while allowing for resource-specific logic and optimizations.

## 2. Architecture Design

### 2.1 Resource Manager Interface
```go
type ResourceManager interface {
    // Core CRUD operations
    Create(ctx context.Context, resource *ResourceSpec) (*ResourceStatus, error)
    Update(ctx context.Context, resource *ResourceSpec) (*ResourceStatus, error)
    Delete(ctx context.Context, resourceID uuid.UUID) error
    Get(ctx context.Context, resourceID uuid.UUID) (*ResourceStatus, error)
    List(ctx context.Context, filters ResourceFilters) ([]*ResourceStatus, error)
    
    // Reconciliation
    Reconcile(ctx context.Context, resource *ResourceSpec) (*ResourceStatus, error)
    GetDesiredState(ctx context.Context, resourceID uuid.UUID) (*ResourceSpec, error)
    GetActualState(ctx context.Context, resourceID uuid.UUID) (*ResourceStatus, error)
    
    // Resource-specific operations
    GetOperations() []ResourceOperation
    ValidateConfig(config map[string]interface{}) error
    GetDefaultConfig() map[string]interface{}
    
    // Lifecycle hooks
    OnCreate(resource *ResourceSpec) error
    OnUpdate(resource *ResourceSpec) error  
    OnDelete(resourceID uuid.UUID) error
    
    // Metadata
    GetResourceType() string
    GetSupportedOperations() []string
    GetConfigSchema() *JSONSchema
}
```

### 2.2 Resource Manager Registry
```go
type ResourceManagerRegistry struct {
    managers map[string]ResourceManager
    mu       sync.RWMutex
}

func NewResourceManagerRegistry() *ResourceManagerRegistry {
    return &ResourceManagerRegistry{
        managers: make(map[string]ResourceManager),
    }
}

func (r *ResourceManagerRegistry) Register(resourceType string, manager ResourceManager) error {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    if _, exists := r.managers[resourceType]; exists {
        return fmt.Errorf("resource manager for type %s already registered", resourceType)
    }
    
    r.managers[resourceType] = manager
    return nil
}

func (r *ResourceManagerRegistry) Get(resourceType string) (ResourceManager, error) {
    r.mu.RLock()
    defer r.mu.RUnlock()
    
    manager, exists := r.managers[resourceType]
    if !exists {
        return nil, fmt.Errorf("no resource manager found for type %s", resourceType)
    }
    
    return manager, nil
}
```

## 3. Core Data Structures

### 3.1 Resource Specification
```go
type ResourceSpec struct {
    ID           uuid.UUID              `json:"id"`
    TenantID     uuid.UUID              `json:"tenant_id"`
    ApplicationID *uuid.UUID            `json:"application_id,omitempty"`
    Type         string                 `json:"type"`
    Name         string                 `json:"name"`
    Config       map[string]interface{} `json:"config"`
    Tags         map[string]string      `json:"tags"`
    Dependencies []ResourceDependency   `json:"dependencies"`
    Metadata     ResourceMetadata       `json:"metadata"`
    CreatedAt    time.Time             `json:"created_at"`
    UpdatedAt    time.Time             `json:"updated_at"`
}

type ResourceDependency struct {
    ResourceID   uuid.UUID `json:"resource_id"`
    ResourceType string    `json:"resource_type"`
    Relationship string    `json:"relationship"` // "requires", "uses", "extends"
}

type ResourceMetadata struct {
    Owner       string            `json:"owner"`
    Team        string            `json:"team"`
    Environment string            `json:"environment"`
    Version     string            `json:"version"`
    Labels      map[string]string `json:"labels"`
}
```

### 3.2 Resource Status
```go
type ResourceStatus struct {
    ID                uuid.UUID              `json:"id"`
    Spec              *ResourceSpec          `json:"spec"`
    Phase             ResourcePhase          `json:"phase"`
    Conditions        []ResourceCondition    `json:"conditions"`
    ObservedGeneration int64                  `json:"observed_generation"`
    ProviderResourceID string                `json:"provider_resource_id"`
    ActualConfig      map[string]interface{} `json:"actual_config"`
    LastReconciled    *time.Time            `json:"last_reconciled"`
    Message           string                `json:"message"`
}

type ResourcePhase string

const (
    PhasePending    ResourcePhase = "Pending"
    PhaseCreating   ResourcePhase = "Creating"
    PhaseReady      ResourcePhase = "Ready"
    PhaseUpdating   ResourcePhase = "Updating"
    PhaseDeleting   ResourcePhase = "Deleting"
    PhaseFailed     ResourcePhase = "Failed"
)

type ResourceCondition struct {
    Type               string      `json:"type"`
    Status             ConditionStatus `json:"status"`
    LastTransitionTime time.Time   `json:"lastTransitionTime"`
    Reason             string      `json:"reason"`
    Message            string      `json:"message"`
}
```

## 4. Database Resource Manager

### 4.1 Database Manager Implementation
```go
type DatabaseManager struct {
    cloudProvider CloudProvider
    db           *sql.DB
    eventBus     EventBus
    config       DatabaseManagerConfig
}

type DatabaseManagerConfig struct {
    SupportedEngines  []string `json:"supported_engines"`
    DefaultEngine     string   `json:"default_engine"`
    AllowedSizes     []string `json:"allowed_sizes"`
    DefaultSize      string   `json:"default_size"`
    BackupRetention  int      `json:"backup_retention_days"`
    MaintenanceWindow string  `json:"maintenance_window"`
}

func (dm *DatabaseManager) Create(ctx context.Context, resource *ResourceSpec) (*ResourceStatus, error) {
    // Validate configuration
    if err := dm.ValidateConfig(resource.Config); err != nil {
        return nil, fmt.Errorf("invalid database configuration: %w", err)
    }
    
    // Extract database-specific configuration
    dbConfig := DatabaseConfig{
        Engine:           dm.getConfigValue(resource.Config, "engine", dm.config.DefaultEngine).(string),
        Size:            dm.getConfigValue(resource.Config, "size", dm.config.DefaultSize).(string),
        DatabaseName:    resource.Name,
        MultiAZ:         dm.getConfigValue(resource.Config, "multi_az", false).(bool),
        BackupRetention: dm.config.BackupRetention,
        Tags: map[string]string{
            "tenant_id":      resource.TenantID.String(),
            "application_id": resource.ApplicationID.String(),
            "managed_by":     "idp-platform",
        },
    }
    
    // Create database instance
    instance, err := dm.cloudProvider.CreateDatabase(ctx, dbConfig)
    if err != nil {
        return &ResourceStatus{
            ID:      resource.ID,
            Spec:    resource,
            Phase:   PhaseFailed,
            Message: fmt.Sprintf("Failed to create database: %v", err),
        }, err
    }
    
    // Update resource status
    status := &ResourceStatus{
        ID:                 resource.ID,
        Spec:               resource,
        Phase:              PhaseCreating,
        ProviderResourceID: instance.ID,
        ActualConfig: map[string]interface{}{
            "engine":      instance.Engine,
            "size":        instance.Size,
            "endpoint":    instance.Endpoint,
            "port":        instance.Port,
            "status":      instance.Status,
        },
        Conditions: []ResourceCondition{
            {
                Type:               "Created",
                Status:             ConditionTrue,
                LastTransitionTime: time.Now(),
                Reason:             "DatabaseInstanceCreated",
                Message:            "Database instance created successfully",
            },
        },
        LastReconciled: &time.Now(),
        Message:        "Database instance is being created",
    }
    
    // Emit event
    dm.eventBus.Emit(Event{
        Type:     "database.creation_started",
        Resource: resource.ID,
        Data:     map[string]interface{}{"instance_id": instance.ID},
    })
    
    return status, nil
}

func (dm *DatabaseManager) ValidateConfig(config map[string]interface{}) error {
    engine, ok := config["engine"].(string)
    if !ok {
        engine = dm.config.DefaultEngine
    }
    
    // Validate engine is supported
    if !dm.isEngineSupported(engine) {
        return fmt.Errorf("unsupported database engine: %s", engine)
    }
    
    // Validate size is allowed
    if size, ok := config["size"].(string); ok {
        if !dm.isSizeAllowed(size) {
            return fmt.Errorf("unsupported database size: %s", size)
        }
    }
    
    return nil
}

func (dm *DatabaseManager) GetConfigSchema() *JSONSchema {
    return &JSONSchema{
        Type: "object",
        Properties: map[string]*JSONSchema{
            "engine": {
                Type:        "string",
                Enum:        dm.config.SupportedEngines,
                Default:     dm.config.DefaultEngine,
                Description: "Database engine type",
            },
            "size": {
                Type:        "string", 
                Enum:        dm.config.AllowedSizes,
                Default:     dm.config.DefaultSize,
                Description: "Database instance size",
            },
            "multi_az": {
                Type:        "boolean",
                Default:     false,
                Description: "Enable Multi-AZ deployment for high availability",
            },
            "backup_window": {
                Type:        "string",
                Pattern:     "^[0-9]{2}:[0-9]{2}-[0-9]{2}:[0-9]{2}$",
                Description: "Daily backup window (HH:MM-HH:MM format)",
            },
        },
        Required: []string{"engine"},
    }
}
```

## 5. Cache Resource Manager

### 5.1 Cache Manager Implementation
```go
type CacheManager struct {
    cloudProvider CloudProvider
    db           *sql.DB
    eventBus     EventBus
    config       CacheManagerConfig
}

type CacheManagerConfig struct {
    SupportedEngines []string `json:"supported_engines"` // redis, memcached
    DefaultEngine    string   `json:"default_engine"`
    AllowedSizes    []string `json:"allowed_sizes"`
    DefaultSize     string   `json:"default_size"`
}

func (cm *CacheManager) Create(ctx context.Context, resource *ResourceSpec) (*ResourceStatus, error) {
    cacheConfig := CacheConfig{
        Engine:      cm.getConfigValue(resource.Config, "engine", cm.config.DefaultEngine).(string),
        Size:        cm.getConfigValue(resource.Config, "size", cm.config.DefaultSize).(string),
        ClusterName: resource.Name,
        NumNodes:    cm.getConfigValue(resource.Config, "num_nodes", 1).(int),
        Tags: map[string]string{
            "tenant_id":      resource.TenantID.String(),
            "application_id": resource.ApplicationID.String(),
            "managed_by":     "idp-platform",
        },
    }
    
    cluster, err := cm.cloudProvider.CreateCacheCluster(ctx, cacheConfig)
    if err != nil {
        return nil, err
    }
    
    return &ResourceStatus{
        ID:                 resource.ID,
        Spec:               resource,
        Phase:              PhaseCreating,
        ProviderResourceID: cluster.ID,
        ActualConfig: map[string]interface{}{
            "engine":    cluster.Engine,
            "size":      cluster.Size,
            "endpoints": cluster.Endpoints,
            "status":    cluster.Status,
        },
        Message: "Cache cluster is being created",
    }, nil
}

func (cm *CacheManager) GetConfigSchema() *JSONSchema {
    return &JSONSchema{
        Type: "object",
        Properties: map[string]*JSONSchema{
            "engine": {
                Type:        "string",
                Enum:        cm.config.SupportedEngines,
                Default:     cm.config.DefaultEngine,
                Description: "Cache engine type",
            },
            "size": {
                Type:        "string",
                Enum:        cm.config.AllowedSizes,
                Default:     cm.config.DefaultSize,
                Description: "Cache instance size",
            },
            "num_nodes": {
                Type:        "integer",
                Minimum:     1,
                Maximum:     20,
                Default:     1,
                Description: "Number of cache nodes",
            },
        },
        Required: []string{"engine"},
    }
}
```

## 6. Git Repository Manager

### 6.1 Git Repository Manager
```go
type GitRepositoryManager struct {
    gitProvider GitProvider
    db         *sql.DB
    eventBus   EventBus
    config     GitManagerConfig
}

type GitManagerConfig struct {
    DefaultProvider     string   `json:"default_provider"`
    DefaultBranch      string   `json:"default_branch"`
    TemplateRepository string   `json:"template_repository"`
    DefaultProtections []string `json:"default_protections"`
}

func (gm *GitRepositoryManager) Create(ctx context.Context, resource *ResourceSpec) (*ResourceStatus, error) {
    repoConfig := GitRepositoryConfig{
        Name:        resource.Name,
        Description: gm.getConfigValue(resource.Config, "description", "").(string),
        Private:     gm.getConfigValue(resource.Config, "private", true).(bool),
        Template:    gm.getConfigValue(resource.Config, "template", "").(string),
        DefaultBranch: gm.config.DefaultBranch,
    }
    
    // Create repository
    repo, err := gm.gitProvider.CreateRepository(ctx, repoConfig)
    if err != nil {
        return nil, err
    }
    
    // Set up branch protection if specified
    if protections := gm.getConfigValue(resource.Config, "branch_protections", nil); protections != nil {
        err = gm.gitProvider.SetBranchProtection(ctx, repo.ID, gm.config.DefaultBranch, protections)
        if err != nil {
            // Log error but don't fail creation
            log.Errorf("Failed to set branch protection for repo %s: %v", repo.Name, err)
        }
    }
    
    return &ResourceStatus{
        ID:                 resource.ID,
        Spec:               resource,
        Phase:              PhaseReady,
        ProviderResourceID: repo.ID,
        ActualConfig: map[string]interface{}{
            "clone_url":   repo.CloneURL,
            "web_url":     repo.WebURL,
            "default_branch": repo.DefaultBranch,
            "private":     repo.Private,
        },
        Message: "Git repository created successfully",
    }, nil
}

func (gm *GitRepositoryManager) GetConfigSchema() *JSONSchema {
    return &JSONSchema{
        Type: "object",
        Properties: map[string]*JSONSchema{
            "description": {
                Type:        "string",
                Description: "Repository description",
            },
            "private": {
                Type:        "boolean",
                Default:     true,
                Description: "Make repository private",
            },
            "template": {
                Type:        "string",
                Description: "Template repository to use",
            },
            "branch_protections": {
                Type: "object",
                Properties: map[string]*JSONSchema{
                    "required_status_checks": {Type: "array"},
                    "enforce_admins": {Type: "boolean"},
                    "required_pull_request_reviews": {Type: "object"},
                },
                Description: "Branch protection rules",
            },
        },
    }
}
```

## 7. CI/CD Pipeline Manager  

### 7.1 Pipeline Manager Implementation
```go
type PipelineManager struct {
    cicdProvider CICDProvider
    db          *sql.DB
    eventBus    EventBus
    config      PipelineManagerConfig
}

type PipelineManagerConfig struct {
    DefaultProvider   string   `json:"default_provider"`
    DefaultTriggers  []string `json:"default_triggers"`
    DefaultStages    []string `json:"default_stages"`
}

func (pm *PipelineManager) Create(ctx context.Context, resource *ResourceSpec) (*ResourceStatus, error) {
    pipelineConfig := PipelineConfig{
        Name:           resource.Name,
        Repository:     pm.getConfigValue(resource.Config, "repository", "").(string),
        Branch:         pm.getConfigValue(resource.Config, "branch", "main").(string),
        Triggers:       pm.getConfigValue(resource.Config, "triggers", pm.config.DefaultTriggers).([]string),
        Stages:         pm.getConfigValue(resource.Config, "stages", pm.config.DefaultStages).([]string),
        Environment:    pm.getConfigValue(resource.Config, "environment", map[string]string{}).(map[string]string),
    }
    
    pipeline, err := pm.cicdProvider.CreatePipeline(ctx, pipelineConfig)
    if err != nil {
        return nil, err
    }
    
    return &ResourceStatus{
        ID:                 resource.ID,
        Spec:               resource,
        Phase:              PhaseReady,
        ProviderResourceID: pipeline.ID,
        ActualConfig: map[string]interface{}{
            "pipeline_url": pipeline.URL,
            "status":       pipeline.Status,
            "triggers":     pipeline.Triggers,
            "stages":       pipeline.Stages,
        },
        Message: "CI/CD pipeline created successfully",
    }, nil
}
```

## 8. Resource Dependency Management

### 8.1 Dependency Resolution
```go
type DependencyResolver struct {
    registry *ResourceManagerRegistry
    db      *sql.DB
}

func (dr *DependencyResolver) ResolveDependencies(ctx context.Context, resource *ResourceSpec) error {
    for _, dep := range resource.Dependencies {
        // Check if dependency exists and is ready
        depStatus, err := dr.getResourceStatus(ctx, dep.ResourceID)
        if err != nil {
            return fmt.Errorf("dependency %s not found: %w", dep.ResourceID, err)
        }
        
        if depStatus.Phase != PhaseReady {
            return fmt.Errorf("dependency %s is not ready (current phase: %s)", dep.ResourceID, depStatus.Phase)
        }
        
        // Inject dependency configuration
        if err := dr.injectDependencyConfig(resource, dep, depStatus); err != nil {
            return fmt.Errorf("failed to inject dependency configuration: %w", err)
        }
    }
    
    return nil
}

func (dr *DependencyResolver) injectDependencyConfig(resource *ResourceSpec, dep ResourceDependency, depStatus *ResourceStatus) error {
    switch dep.ResourceType {
    case "database":
        // Inject database connection information
        if endpoint, ok := depStatus.ActualConfig["endpoint"].(string); ok {
            resource.Config["database_endpoint"] = endpoint
        }
        if port, ok := depStatus.ActualConfig["port"].(float64); ok {
            resource.Config["database_port"] = int(port)
        }
    
    case "cache":
        // Inject cache connection information
        if endpoints, ok := depStatus.ActualConfig["endpoints"].([]interface{}); ok {
            resource.Config["cache_endpoints"] = endpoints
        }
    }
    
    return nil
}
```

## 9. Configuration Validation and Templating

### 9.1 JSON Schema Validation
```go
type JSONSchema struct {
    Type        string                    `json:"type"`
    Properties  map[string]*JSONSchema   `json:"properties,omitempty"`
    Items       *JSONSchema              `json:"items,omitempty"`
    Required    []string                 `json:"required,omitempty"`
    Enum        []interface{}            `json:"enum,omitempty"`
    Default     interface{}              `json:"default,omitempty"`
    Minimum     *float64                 `json:"minimum,omitempty"`
    Maximum     *float64                 `json:"maximum,omitempty"`
    Pattern     string                   `json:"pattern,omitempty"`
    Description string                   `json:"description,omitempty"`
}

func ValidateAgainstSchema(config map[string]interface{}, schema *JSONSchema) error {
    // Implementation would use a JSON schema validation library
    // like github.com/xeipuuv/gojsonschema
    return nil
}
```

This resource manager architecture provides a flexible, extensible foundation for managing diverse infrastructure resources while maintaining consistency in operations, validation, and lifecycle management.
